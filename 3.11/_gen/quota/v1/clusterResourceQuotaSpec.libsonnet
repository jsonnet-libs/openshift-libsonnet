{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='clusterResourceQuotaSpec', url='', help='"ClusterResourceQuotaSpec defines the desired quota restrictions"'),
  '#quota':: d.obj(help='"ResourceQuotaSpec defines the desired hard limits to enforce for Quota."'),
  quota: {
    '#scopeSelector':: d.obj(help='"A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements."'),
    scopeSelector: {
      '#withMatchExpressions':: d.fn(help='"A list of scope selector requirements by scope of the resources."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
      withMatchExpressions(matchExpressions): { quota+: { scopeSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
      '#withMatchExpressionsMixin':: d.fn(help='"A list of scope selector requirements by scope of the resources."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
      withMatchExpressionsMixin(matchExpressions): { quota+: { scopeSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
    },
    '#withHard':: d.fn(help='"hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/"', args=[d.arg(name='hard', type=d.T.object)]),
    withHard(hard): { quota+: { hard: hard } },
    '#withHardMixin':: d.fn(help='"hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hard', type=d.T.object)]),
    withHardMixin(hard): { quota+: { hard+: hard } },
    '#withScopes':: d.fn(help='"A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects."', args=[d.arg(name='scopes', type=d.T.array)]),
    withScopes(scopes): { quota+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } },
    '#withScopesMixin':: d.fn(help='"A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
    withScopesMixin(scopes): { quota+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } },
  },
  '#selector':: d.obj(help='"ClusterResourceQuotaSelector is used to select projects.  At least one of LabelSelector or AnnotationSelector must present.  If only one is present, it is the only selection criteria.  If both are specified, the project must match both restrictions."'),
  selector: {
    '#labels':: d.obj(help='"A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects."'),
    labels: {
      '#withMatchExpressions':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
      withMatchExpressions(matchExpressions): { selector+: { labels+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
      '#withMatchExpressionsMixin':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
      withMatchExpressionsMixin(matchExpressions): { selector+: { labels+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
      '#withMatchLabels':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."', args=[d.arg(name='matchLabels', type=d.T.object)]),
      withMatchLabels(matchLabels): { selector+: { labels+: { matchLabels: matchLabels } } },
      '#withMatchLabelsMixin':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
      withMatchLabelsMixin(matchLabels): { selector+: { labels+: { matchLabels+: matchLabels } } },
    },
    '#withAnnotations':: d.fn(help='"AnnotationSelector is used to select projects by annotation."', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { selector+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"AnnotationSelector is used to select projects by annotation."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { selector+: { annotations+: annotations } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
