{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='buildSource', url='', help='"BuildSource is the SCM used for the build."'),
  '#binary':: d.obj(help='"BinaryBuildSource describes a binary file to be used for the Docker and Source build strategies, where the file will be extracted and used as the build source."'),
  binary: {
    '#withAsFile':: d.fn(help="\"asFile indicates that the provided binary input should be considered a single file within the build input. For example, specifying \\\"webapp.war\\\" would place the provided binary as `/webapp.war` for the builder. If left empty, the Docker and Source build strategies assume this file is a zip, tar, or tar.gz file and extract it as the source. The custom strategy receives this binary as standard input. This filename may not contain slashes or be '..' or '.'.\"", args=[d.arg(name='asFile', type=d.T.string)]),
    withAsFile(asFile): { binary+: { asFile: asFile } },
  },
  '#git':: d.obj(help='"GitBuildSource defines the parameters of a Git SCM"'),
  git: {
    '#withHttpProxy':: d.fn(help='"httpProxy is a proxy used to reach the git repository over http"', args=[d.arg(name='httpProxy', type=d.T.string)]),
    withHttpProxy(httpProxy): { git+: { httpProxy: httpProxy } },
    '#withHttpsProxy':: d.fn(help='"httpsProxy is a proxy used to reach the git repository over https"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
    withHttpsProxy(httpsProxy): { git+: { httpsProxy: httpsProxy } },
    '#withNoProxy':: d.fn(help='"noProxy is the list of domains for which the proxy should not be used"', args=[d.arg(name='noProxy', type=d.T.string)]),
    withNoProxy(noProxy): { git+: { noProxy: noProxy } },
    '#withRef':: d.fn(help='"ref is the branch/tag/ref to build."', args=[d.arg(name='ref', type=d.T.string)]),
    withRef(ref): { git+: { ref: ref } },
    '#withUri':: d.fn(help='"uri points to the source that will be built. The structure of the source will depend on the type of build to run"', args=[d.arg(name='uri', type=d.T.string)]),
    withUri(uri): { git+: { uri: uri } },
  },
  '#sourceSecret':: d.obj(help='"LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace."'),
  sourceSecret: {
    '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { sourceSecret+: { name: name } },
  },
  '#withConfigMaps':: d.fn(help='"configMaps represents a list of configMaps and their destinations that will be used for the build."', args=[d.arg(name='configMaps', type=d.T.array)]),
  withConfigMaps(configMaps): { configMaps: if std.isArray(v=configMaps) then configMaps else [configMaps] },
  '#withConfigMapsMixin':: d.fn(help='"configMaps represents a list of configMaps and their destinations that will be used for the build."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='configMaps', type=d.T.array)]),
  withConfigMapsMixin(configMaps): { configMaps+: if std.isArray(v=configMaps) then configMaps else [configMaps] },
  '#withContextDir':: d.fn(help='"contextDir specifies the sub-directory where the source code for the application exists. This allows to have buildable sources in directory other than root of repository."', args=[d.arg(name='contextDir', type=d.T.string)]),
  withContextDir(contextDir): { contextDir: contextDir },
  '#withDockerfile':: d.fn(help='"dockerfile is the raw contents of a Dockerfile which should be built. When this option is specified, the FROM may be modified based on your strategy base image and additional ENV stanzas from your strategy environment will be added after the FROM, but before the rest of your Dockerfile stanzas. The Dockerfile source type may be used with other options like git - in those cases the Git repo will have any innate Dockerfile replaced in the context dir."', args=[d.arg(name='dockerfile', type=d.T.string)]),
  withDockerfile(dockerfile): { dockerfile: dockerfile },
  '#withImages':: d.fn(help='"images describes a set of images to be used to provide source for the build"', args=[d.arg(name='images', type=d.T.array)]),
  withImages(images): { images: if std.isArray(v=images) then images else [images] },
  '#withImagesMixin':: d.fn(help='"images describes a set of images to be used to provide source for the build"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='images', type=d.T.array)]),
  withImagesMixin(images): { images+: if std.isArray(v=images) then images else [images] },
  '#withSecrets':: d.fn(help='"secrets represents a list of secrets and their destinations that will be used only for the build."', args=[d.arg(name='secrets', type=d.T.array)]),
  withSecrets(secrets): { secrets: if std.isArray(v=secrets) then secrets else [secrets] },
  '#withSecretsMixin':: d.fn(help='"secrets represents a list of secrets and their destinations that will be used only for the build."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='secrets', type=d.T.array)]),
  withSecretsMixin(secrets): { secrets+: if std.isArray(v=secrets) then secrets else [secrets] },
  '#withType':: d.fn(help='"type of build input to accept"', args=[d.arg(name='type', type=d.T.string)]),
  withType(type): { type: type },
  '#mixin': 'ignore',
  mixin: self,
}
