{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='roleBindingRestrictionSpec', url='', help='"RoleBindingRestrictionSpec defines a rolebinding restriction.  Exactly one field must be non-nil."'),
  '#grouprestriction':: d.obj(help='"GroupRestriction matches a group either by a string match on the group name or a label selector applied to group labels."'),
  grouprestriction: {
    '#withGroups':: d.fn(help="\"Groups is a list of groups used to match against an individual user's groups. If the user is a member of one of the whitelisted groups, the user is allowed to be bound to a role.\"", args=[d.arg(name='groups', type=d.T.array)]),
    withGroups(groups): { grouprestriction+: { groups: if std.isArray(v=groups) then groups else [groups] } },
    '#withGroupsMixin':: d.fn(help="\"Groups is a list of groups used to match against an individual user's groups. If the user is a member of one of the whitelisted groups, the user is allowed to be bound to a role.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='groups', type=d.T.array)]),
    withGroupsMixin(groups): { grouprestriction+: { groups+: if std.isArray(v=groups) then groups else [groups] } },
    '#withLabels':: d.fn(help='"Selectors specifies a list of label selectors over group labels."', args=[d.arg(name='labels', type=d.T.array)]),
    withLabels(labels): { grouprestriction+: { labels: if std.isArray(v=labels) then labels else [labels] } },
    '#withLabelsMixin':: d.fn(help='"Selectors specifies a list of label selectors over group labels."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.array)]),
    withLabelsMixin(labels): { grouprestriction+: { labels+: if std.isArray(v=labels) then labels else [labels] } },
  },
  '#serviceaccountrestriction':: d.obj(help="\"ServiceAccountRestriction matches a service account by a string match on either the service-account name or the name of the service account's namespace.\""),
  serviceaccountrestriction: {
    '#withNamespaces':: d.fn(help='"Namespaces specifies a list of literal namespace names."', args=[d.arg(name='namespaces', type=d.T.array)]),
    withNamespaces(namespaces): { serviceaccountrestriction+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
    '#withNamespacesMixin':: d.fn(help='"Namespaces specifies a list of literal namespace names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
    withNamespacesMixin(namespaces): { serviceaccountrestriction+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
    '#withServiceaccounts':: d.fn(help='"ServiceAccounts specifies a list of literal service-account names."', args=[d.arg(name='serviceaccounts', type=d.T.array)]),
    withServiceaccounts(serviceaccounts): { serviceaccountrestriction+: { serviceaccounts: if std.isArray(v=serviceaccounts) then serviceaccounts else [serviceaccounts] } },
    '#withServiceaccountsMixin':: d.fn(help='"ServiceAccounts specifies a list of literal service-account names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='serviceaccounts', type=d.T.array)]),
    withServiceaccountsMixin(serviceaccounts): { serviceaccountrestriction+: { serviceaccounts+: if std.isArray(v=serviceaccounts) then serviceaccounts else [serviceaccounts] } },
  },
  '#userrestriction':: d.obj(help='"UserRestriction matches a user either by a string match on the user name, a string match on the name of a group to which the user belongs, or a label selector applied to the user labels."'),
  userrestriction: {
    '#withGroups':: d.fn(help='"Groups specifies a list of literal group names."', args=[d.arg(name='groups', type=d.T.array)]),
    withGroups(groups): { userrestriction+: { groups: if std.isArray(v=groups) then groups else [groups] } },
    '#withGroupsMixin':: d.fn(help='"Groups specifies a list of literal group names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groups', type=d.T.array)]),
    withGroupsMixin(groups): { userrestriction+: { groups+: if std.isArray(v=groups) then groups else [groups] } },
    '#withLabels':: d.fn(help='"Selectors specifies a list of label selectors over user labels."', args=[d.arg(name='labels', type=d.T.array)]),
    withLabels(labels): { userrestriction+: { labels: if std.isArray(v=labels) then labels else [labels] } },
    '#withLabelsMixin':: d.fn(help='"Selectors specifies a list of label selectors over user labels."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.array)]),
    withLabelsMixin(labels): { userrestriction+: { labels+: if std.isArray(v=labels) then labels else [labels] } },
    '#withUsers':: d.fn(help='"Users specifies a list of literal user names."', args=[d.arg(name='users', type=d.T.array)]),
    withUsers(users): { userrestriction+: { users: if std.isArray(v=users) then users else [users] } },
    '#withUsersMixin':: d.fn(help='"Users specifies a list of literal user names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='users', type=d.T.array)]),
    withUsersMixin(users): { userrestriction+: { users+: if std.isArray(v=users) then users else [users] } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
