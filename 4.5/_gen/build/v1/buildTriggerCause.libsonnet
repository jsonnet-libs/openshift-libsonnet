{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='buildTriggerCause', url='', help='"BuildTriggerCause holds information about a triggered build. It is used for displaying build trigger data for each build and build configuration in oc describe. It is also used to describe which triggers led to the most recent update in the build configuration."'),
  '#bitbucketWebHook':: d.obj(help='"BitbucketWebHookCause has information about a Bitbucket webhook that triggered a build."'),
  bitbucketWebHook: {
    '#revision':: d.obj(help='"SourceRevision is the revision or commit information from the source for the build"'),
    revision: {
      '#git':: d.obj(help='"GitSourceRevision is the commit information from a git source for a build"'),
      git: {
        '#author':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        author: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { bitbucketWebHook+: { revision+: { git+: { author+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { bitbucketWebHook+: { revision+: { git+: { author+: { name: name } } } } },
        },
        '#committer':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        committer: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { bitbucketWebHook+: { revision+: { git+: { committer+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { bitbucketWebHook+: { revision+: { git+: { committer+: { name: name } } } } },
        },
        '#withCommit':: d.fn(help='"commit is the commit hash identifying a specific commit"', args=[d.arg(name='commit', type=d.T.string)]),
        withCommit(commit): { bitbucketWebHook+: { revision+: { git+: { commit: commit } } } },
        '#withMessage':: d.fn(help='"message is the description of a specific commit"', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { bitbucketWebHook+: { revision+: { git+: { message: message } } } },
      },
      '#withType':: d.fn(help="\"type of the build source, may be one of 'Source', 'Dockerfile', 'Binary', or 'Images'\"", args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { bitbucketWebHook+: { revision+: { type: type } } },
    },
    '#withSecret':: d.fn(help='"Secret is the obfuscated webhook secret that triggered a build."', args=[d.arg(name='secret', type=d.T.string)]),
    withSecret(secret): { bitbucketWebHook+: { secret: secret } },
  },
  '#genericWebHook':: d.obj(help='"GenericWebHookCause holds information about a generic WebHook that triggered a build."'),
  genericWebHook: {
    '#revision':: d.obj(help='"SourceRevision is the revision or commit information from the source for the build"'),
    revision: {
      '#git':: d.obj(help='"GitSourceRevision is the commit information from a git source for a build"'),
      git: {
        '#author':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        author: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { genericWebHook+: { revision+: { git+: { author+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { genericWebHook+: { revision+: { git+: { author+: { name: name } } } } },
        },
        '#committer':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        committer: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { genericWebHook+: { revision+: { git+: { committer+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { genericWebHook+: { revision+: { git+: { committer+: { name: name } } } } },
        },
        '#withCommit':: d.fn(help='"commit is the commit hash identifying a specific commit"', args=[d.arg(name='commit', type=d.T.string)]),
        withCommit(commit): { genericWebHook+: { revision+: { git+: { commit: commit } } } },
        '#withMessage':: d.fn(help='"message is the description of a specific commit"', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { genericWebHook+: { revision+: { git+: { message: message } } } },
      },
      '#withType':: d.fn(help="\"type of the build source, may be one of 'Source', 'Dockerfile', 'Binary', or 'Images'\"", args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { genericWebHook+: { revision+: { type: type } } },
    },
    '#withSecret':: d.fn(help='"secret is the obfuscated webhook secret that triggered a build."', args=[d.arg(name='secret', type=d.T.string)]),
    withSecret(secret): { genericWebHook+: { secret: secret } },
  },
  '#githubWebHook':: d.obj(help='"GitHubWebHookCause has information about a GitHub webhook that triggered a build."'),
  githubWebHook: {
    '#revision':: d.obj(help='"SourceRevision is the revision or commit information from the source for the build"'),
    revision: {
      '#git':: d.obj(help='"GitSourceRevision is the commit information from a git source for a build"'),
      git: {
        '#author':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        author: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { githubWebHook+: { revision+: { git+: { author+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { githubWebHook+: { revision+: { git+: { author+: { name: name } } } } },
        },
        '#committer':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        committer: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { githubWebHook+: { revision+: { git+: { committer+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { githubWebHook+: { revision+: { git+: { committer+: { name: name } } } } },
        },
        '#withCommit':: d.fn(help='"commit is the commit hash identifying a specific commit"', args=[d.arg(name='commit', type=d.T.string)]),
        withCommit(commit): { githubWebHook+: { revision+: { git+: { commit: commit } } } },
        '#withMessage':: d.fn(help='"message is the description of a specific commit"', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { githubWebHook+: { revision+: { git+: { message: message } } } },
      },
      '#withType':: d.fn(help="\"type of the build source, may be one of 'Source', 'Dockerfile', 'Binary', or 'Images'\"", args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { githubWebHook+: { revision+: { type: type } } },
    },
    '#withSecret':: d.fn(help='"secret is the obfuscated webhook secret that triggered a build."', args=[d.arg(name='secret', type=d.T.string)]),
    withSecret(secret): { githubWebHook+: { secret: secret } },
  },
  '#gitlabWebHook':: d.obj(help='"GitLabWebHookCause has information about a GitLab webhook that triggered a build."'),
  gitlabWebHook: {
    '#revision':: d.obj(help='"SourceRevision is the revision or commit information from the source for the build"'),
    revision: {
      '#git':: d.obj(help='"GitSourceRevision is the commit information from a git source for a build"'),
      git: {
        '#author':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        author: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { gitlabWebHook+: { revision+: { git+: { author+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { gitlabWebHook+: { revision+: { git+: { author+: { name: name } } } } },
        },
        '#committer':: d.obj(help='"SourceControlUser defines the identity of a user of source control"'),
        committer: {
          '#withEmail':: d.fn(help='"email of the source control user"', args=[d.arg(name='email', type=d.T.string)]),
          withEmail(email): { gitlabWebHook+: { revision+: { git+: { committer+: { email: email } } } } },
          '#withName':: d.fn(help='"name of the source control user"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { gitlabWebHook+: { revision+: { git+: { committer+: { name: name } } } } },
        },
        '#withCommit':: d.fn(help='"commit is the commit hash identifying a specific commit"', args=[d.arg(name='commit', type=d.T.string)]),
        withCommit(commit): { gitlabWebHook+: { revision+: { git+: { commit: commit } } } },
        '#withMessage':: d.fn(help='"message is the description of a specific commit"', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { gitlabWebHook+: { revision+: { git+: { message: message } } } },
      },
      '#withType':: d.fn(help="\"type of the build source, may be one of 'Source', 'Dockerfile', 'Binary', or 'Images'\"", args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { gitlabWebHook+: { revision+: { type: type } } },
    },
    '#withSecret':: d.fn(help='"Secret is the obfuscated webhook secret that triggered a build."', args=[d.arg(name='secret', type=d.T.string)]),
    withSecret(secret): { gitlabWebHook+: { secret: secret } },
  },
  '#imageChangeBuild':: d.obj(help='"ImageChangeCause contains information about the image that triggered a build"'),
  imageChangeBuild: {
    '#fromRef':: d.obj(help='"ObjectReference contains enough information to let you inspect or modify the referred object."'),
    fromRef: {
      '#withApiVersion':: d.fn(help='"API version of the referent."', args=[d.arg(name='apiVersion', type=d.T.string)]),
      withApiVersion(apiVersion): { imageChangeBuild+: { fromRef+: { apiVersion: apiVersion } } },
      '#withFieldPath':: d.fn(help='"If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \\"spec.containers{name}\\" (where \\"name\\" refers to the name of the container that triggered the event) or if no container name is specified \\"spec.containers[2]\\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object."', args=[d.arg(name='fieldPath', type=d.T.string)]),
      withFieldPath(fieldPath): { imageChangeBuild+: { fromRef+: { fieldPath: fieldPath } } },
      '#withKind':: d.fn(help='"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds"', args=[d.arg(name='kind', type=d.T.string)]),
      withKind(kind): { imageChangeBuild+: { fromRef+: { kind: kind } } },
      '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { imageChangeBuild+: { fromRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { imageChangeBuild+: { fromRef+: { namespace: namespace } } },
      '#withResourceVersion':: d.fn(help='"Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
      withResourceVersion(resourceVersion): { imageChangeBuild+: { fromRef+: { resourceVersion: resourceVersion } } },
      '#withUid':: d.fn(help='"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"', args=[d.arg(name='uid', type=d.T.string)]),
      withUid(uid): { imageChangeBuild+: { fromRef+: { uid: uid } } },
    },
    '#withImageID':: d.fn(help='"imageID is the ID of the image that triggered a a new build."', args=[d.arg(name='imageID', type=d.T.string)]),
    withImageID(imageID): { imageChangeBuild+: { imageID: imageID } },
  },
  '#withMessage':: d.fn(help='"message is used to store a human readable message for why the build was triggered. E.g.: \\"Manually triggered by user\\", \\"Configuration change\\",etc."', args=[d.arg(name='message', type=d.T.string)]),
  withMessage(message): { message: message },
  '#mixin': 'ignore',
  mixin: self,
}
